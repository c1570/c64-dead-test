;---------------------------------------------------------------------------------------------------------------------------
; "C-64 DEAD TEST REV 781220"
; https://github.com/c1570/c64-dead-test
;
; Disassembled source code of original Dead Test - copyright, credits, status unknown.
; Comments, "improvements", fixes, etc., up to 006 by kinzi @ Forum64, see https://www.forum64.de/
; More recent changes authors see Git
;---------------------------------------------------------------------------------------------------------------------------

                    !to "dead_test.bin", plain

;---------------------------------------------------------------------------------------------------------------------------
;
; Memory layout for "Dead Test"
;
; $0400..$07FF = screen RAM
; $0800..$09FF = char set in RAM
; $D800..$DBFF = color RAM
; $DC00..$DFFF = I/O
; $F800..$F9FF = char set in ROM
; 
;---------------------------------------------------------------------------------------------------------------------------
;
; CPU I/O Port:
;
; P0 - "/LORAM"                 - no impact in Ultimax Mode
; P1 - "/HIRAM"                 - no impact in Ultimax Mode
; P2 - "/CHAREN"                - no impact in Ultimax Mode
; P3 - "CASS WRITE" (Pin "E/5") - bit 3 (dec 8)
; P4 - "CASS SENSE" (Pin "F/6") - bit 4 (dec 16) 
; P5 - "CASS MOTOR" (Pin "C/3") - bit 5 (dec 32)
;
; P3/P4 could be used for status LEDs
;
; In the 586220 harness CASS_WRITE and CASS_MOTOR are interconnected through resistors, CASS_READ and CASS_SENSE are
; directly connected together. So CASS_SENSE and CASS_MOTOR could be used for LEDs (and _will_ be in Check64 V2.0).
;
;---------------------------------------------------------------------------------------------------------------------------
;
; Using startup colors like in Amiga self diag at startup ...
;
; Startup               = light grey             CASS MOTOR = 1 ; CASS SENSE = 1 (CPU default)
;
; Initial RAM Test using test patterns 00 55 aa ff 01 02 04 08 10 20 40 80 fe fd fb f7 ef df bf 7f
;
; Pattern 00 "00000000"   -> light grey		 CASS MOTOR = 0 ; CASS SENSE = 0 - inverted on every single next step
; Pattern 55 "01010101"   -> light blue
; Pattern aa "10101010"   -> light green
; Pattern ff "11111111"   -> grey
; Pattern 01 "00000001"   -> dark grey
; Pattern 02 "00000010"   -> light red
; Pattern 04 "00000100"   -> brown
; Pattern 08 "00001000"   -> orange
; Pattern 10 "00010000"   -> yellow
; Pattern 20 "00100000"   -> blue
; Pattern 40 "01000000"   -> green
; Pattern 80 "10000000"   -> purple
; Pattern fe "10000000"   -> purple
; Pattern fd "11111110"   -> cyan
; Pattern fb "11111101"   -> red
; Pattern f7 "11111011"   -> white
; Pattern ef "11110111"   -> black
; Pattern df "11101111"   -> light grey
; Pattern bf "11011111"   -> light blue
; Pattern 7f "10111111"   -> light green
;
; Main Test             = (standard)             CASS MOTOR = 0 ; CASS SENSE = 1 (swap every TOD clock update)
;
; On RAM test errors both LEDs just blink in sync with the border screen color
;
;---------------------------------------------------------------------------------------------------------------------------

; these are all zeropage locations that get used in the code
passCounterLo  = $02
passCounterHi  = passCounterLo + 1
tmp1Ptr        = passCounterHi + 1
tmp1PtrHi      = tmp1Ptr + 1
tmp2Ptr        = tmp1PtrHi + 1
tmp2PtrHi      = tmp2Ptr + 1
prngX          = tmp2PtrHi + 1
prngY          = prngX + 1
prngZ          = prngY + 1
prngA          = prngZ + 1
prngT          = prngA + 1

firstUnusedZP  = prngT + 1

ScreenMemStart = $0400
ColMemStart = $d800

ZPMsgOff = 80
ColMsgOff = 120
RamMsgOff = 160
SoundMsgOff = 200

;---------------------------------------------------------------------------------------------------------------------------
; PRNG routine
;---------------------------------------------------------------------------------------------------------------------------

; the following is a port of rng-4261412736 by Edward Rosten, https://github.com/edrosten/8bit_rng
; based on the xorshift algorithm

; implemented as macros to not clobber the stack

!macro PRNG_Init {             ; init PRNG using A
                    sta prngA
                    lda #$00
                    sta prngX
                    sta prngY
                    sta prngZ
}

!macro PRNG_Generate {         ; returns one new PRNG byte in A, doesn't clobber any other register
                    lda prngX
                    rol
                    rol
                    rol
                    rol
                    and #$f0
                    eor prngX
                    sta prngT  ; t = x ^ (x << 4)
                    lda prngY
                    sta prngX  ; x = y
                    lda prngZ
                    sta prngY  ; y = t
                    lda prngA
                    sta prngZ  ; z = a
                    eor prngT
                    sta prngA  ; a = z ^ t ...
                    lda prngZ
                    clc
                    ror
                    eor prngA
                    sta prngA  ; ... ^ (z >> 1)
                    lda prngT
                    clc
                    rol
                    eor prngA
                    sta prngA  ; ... ^ (t << 1)
}

;---------------------------------------------------------------------------------------------------------------------------
; other macros
;---------------------------------------------------------------------------------------------------------------------------

!macro Flip_Cass_Port_A { ; flip cassette port lines, clobbers A
                    lda #$30                ; xxMSWxxx : CASS MOTOR = "M",   CASS SENSE = "S",   CASS WRITE = "W"
                    eor $01                 ; 00110000 ; flip CASS MOTOR and CASS SENSE
                    sta $01
}

!macro CopyCharSet_AXY { ; copy charset from ROM to RAM, clobbers A,X,Y
                    lda #<CharSet           ; copy char set to $0800
                    ldx #>CharSet
                    sta tmp1Ptr
                    stx tmp1PtrHi
                    lda #$00
                    ldx #$08
                    sta tmp2Ptr
                    stx tmp2PtrHi
                    ldx #$01                ; copy two pages (512 bytes)
                    ldy #$00
-                   lda (tmp1Ptr),y
                    sta (tmp2Ptr),y
                    iny
                    bne -
                    inc tmp1PtrHi
                    inc tmp2PtrHi
                    dex
                    bpl -
}

!macro CopyStr_AX .sourcePtr, .destPtr, .len {
                    ldx #.len
-                   lda .sourcePtr,x
                    sta .destPtr,x
                    dex
                    bpl -
}

;---------------------------------------------------------------------------------------------------------------------------
; start of code
;---------------------------------------------------------------------------------------------------------------------------


                    *= $e000

Reset_Handler       sei
                    ldx #$ff                
                    stx $d020               ; patch by kinzi: set screen color to different color (from black) as early as possible
                    txs
                    cld

                    lda #$c7                ; xx000xxx : CASS MOTOR = 0,   CASS SENSE = 0,   CASS WRITE = 0
                    sta $01
                    lda #$37                ; xx110xxx : CASS MOTOR = out, CASS SENSE = out, CASS WRITE = in
                    sta $00
                    
                    jmp InitialRamTest      ; jump to initial RAM test
                    
;---------------------------------------------------------------------------------------------------------------------------
; Main Test
; Stack and ZP have tested okay in initial RAM test, so we're free to use those from here on.
; Still, keep testing and be defensive - problems may occur once the machine has warmed up
;---------------------------------------------------------------------------------------------------------------------------

MainTestStart       +Flip_Cass_Port_A
                    +CopyCharSet_AXY

CiaRegInit1         ldx #$04
CiaRegInit1_1       lda Cia1Init,x          ; CIA init
                    sta $dc07,x
                    lda Cia2Init,x
                    sta $dd07,x
                    dex
                    bne CiaRegInit1_1

CiaRegInit2         lda #$08                ; CIA init part 2
                    sta $dc0f
                    sta $dd0f
                    lda #$48
                    sta $dc0e
                    lda #$08
                    sta $dd0e

                    ldx #$00
                    stx passCounterLo
                    stx passCounterHi

MainTestLoop        ldx #$2f                ; VIC register init
-                   lda VicInit,x
                    sta $d000,x
                    dex
                    bpl -

                    ldy #$00                ; flag for SetupTextScreen to use RTS
                    jsr SetupTextScreen
                    jsr UpdateTod1Display
                    jsr Test_ZeroPage
                    +Flip_Cass_Port_A
                    jsr UpdateTod1Display
                    jsr Test_ColorRam
                    jsr UpdateTod1Display
                    jmp Test_RamTest        ; Clobbers everything but the very first ZP bytes so don't use JSR
BackFromRAMTest     jsr UpdateTod1Display
                    jsr Test_SoundTest

                    sed                     ; update COUNT
                    lda #$01
                    clc
                    adc passCounterLo
                    sta passCounterLo
                    lda #$00
                    adc passCounterHi
                    sta passCounterHi
                    cld

                    +Flip_Cass_Port_A
                    jmp MainTestLoop


;---------------------------------------------------------------------------------------------------------------------------
; (Initial) Screen Setup
; NOTE! If this is called with Y>0, it's not using RTS to exit but JMP Test_RamTest_Return
;---------------------------------------------------------------------------------------------------------------------------

SetupTextScreen     ldx #$00                ; clear screen following
ClearScreen_1       lda #$20
                    sta $0400,x
                    sta $0500,x
                    sta $0600,x
                    sta $0700,x
                    lda #$06                ; set char color on whole screen
                    sta $d800,x
                    sta $d900,x
                    sta $da00,x
                    sta $db00,x
                    inx
                    bne ClearScreen_1

OutText_Header      ldx #$27                ; 40 chars (header)
-                   lda StatusHeader,x      ; fetch text
                    sta $0630,x             ; store to screen RAM
                    lda ColorTextBad        ; RED color
                    sta $da30,x             ; fill color RAM
                    dex
                    bpl -

                    +CopyStr_AX strZeroPage, ScreenMemStart+ZPMsgOff, 8
                    +CopyStr_AX strColorRam, ScreenMemStart+ColMsgOff, 8
                    +CopyStr_AX strRamTest, ScreenMemStart+RamMsgOff, 12
                    +CopyStr_AX strSoundTest, ScreenMemStart+SoundMsgOff, 9
                    
OutText_Status      ldx #$00                ; output a string terminated by "FF"
-                   lda StatusText,x        ; fetch text
                    cmp #$ff                ; eot flag detected?
                    beq OutColor_Status     ; yes, continue
                    sta $0658,x             ; no, store to screen RAM
                    inx
                    jmp -                   ; loop on
                    
OutColor_Status     ldx #$00                ; write correct colors to color RAM, values are terminated by "FF"
-                   lda StatusColor,x       ; fetch color
                    cmp #$ff                ; eot flag detected?
                    beq OutText_Footer      ; yes, continue
                    sta $da58,x             ; no, store to color RAM
                    inx
                    jmp -                   ; loop on
                    
OutText_Footer      ldx #$27                ; 40 chars (footer)
OutText_Footer_1    lda StatusFooter,x
                    sta $0748,x
                    lda ColorTextBad        ; RED color
                    sta $db48,x             ; fill color RAM
                    dex
                    bpl OutText_Footer_1

OutText_Caption     ldx #$27
OutText_Caption_1   lda strCaption,x        ; write program title to screen
                    sta ScreenMemStart,x
                    dex
                    bpl OutText_Caption_1
                    
OutText_Count       ldx #$04
OutText_Count_1     lda strCount,x          ; write "COUNT"
                    sta ScreenMemStart+$03c0,x
                    dex
                    bpl OutText_Count_1
                    
                    lda passCounterLo       ; output counter digit 1
                    and #$0f
                    ora #$30
                    sta $07c9
                    
                    lda passCounterLo       ; output counter digit 2
                    lsr
                    lsr
                    lsr
                    lsr
                    and #$0f
                    ora #$30
                    sta $07c8
                    
                    lda passCounterHi       ; output counter digit 3
                    and #$0f
                    ora #$30
                    sta $07c7
                    
                    lda passCounterHi       ; output counter digit 4
                    lsr
                    lsr
                    lsr
                    lsr
                    and #$0f
                    ora #$30
                    sta $07c6

                    cpy #$00
                    beq +
                    jmp Test_RamTest_Return
+                   rts

;---------------------------------------------------------------------------------------------------------------------------
; Initial RAM Test 
;---------------------------------------------------------------------------------------------------------------------------

InitialRamTest      ldx #$15                ; 22 test patterns
                    ldy #$00
NextTestPattern     lda TestPatterns,x      ; fetch test TestPattern no. x
                    sta $0100,y             ; write to RAM pages
                    sta $0200,y
                    sta $0300,y
                    sta $0400,y
                    sta $0500,y
                    sta $0600,y
                    sta $0700,y
                    sta $0800,y
                    sta $0900,y
                    sta $0a00,y
                    sta $0b00,y
                    sta $0c00,y
                    sta $0d00,y
                    sta $0e00,y
                    sta $0f00,y
                    iny
                    bne NextTestPattern     ; loop on

                    dec $d020               ; activity control
                    +Flip_Cass_Port_A
					
                    txa
                    ldx #$00
                    ldy #$00            
InitRamTest_Delay   dey                     ; delay 256 * 5 cycles = 1.25 ms
                    bne InitRamTest_Delay
                    dex                     ; delay 256 times = about 80 ms
                    bne InitRamTest_Delay
                    tax

ReCheckTestPattern  lda $0100,y             ; now re-read RAM pages and compare with stored values
                    cmp TestPatterns,x
                    bne ErrorHandler        ; on error branch to error handler
                    lda $0200,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0300,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0400,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0500,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0600,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0700,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0800,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0900,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0a00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0b00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0c00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0d00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0e00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0f00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    iny
                    beq PatternComplete     ; already looped through whole RAM page?
                    jmp ReCheckTestPattern  ; no -> loop on
                    
ErrorHandler        jmp BlinkOutRamError               ; error handler for RAM Test errors
                    
PatternComplete     dex                     ; no errors, continue with next pattern
                    bmi Thorough512Test     ; all patterns tested?
                    ldy #$00                ; no
                    jmp NextTestPattern     ; run RAM test with next pattern
                    
Thorough512Test     ldx #$00                ; do a slightly more thorough check on ZP/stack
--                  ldy #$02
                    stx $d020
-                   txa
                    sta $0000,y             ; write 0,1,2,3,4... to $0002... (in run 0)
                    eor #$55                ; EOR to make sure we detect broken A8
                    sta $0100,y             ; write $55,$54,$57,$56,$51... to $0102...
                    inx
                    iny
                    bne -

                    ldy #$02
                    inx                     ; roll over X to its initial value
                    inx
-                   txa
                    cmp $0000,y
                    bne Thorough512Err
                    eor #$55
                    cmp $0100,y
                    bne Thorough512Err
                    inx
                    iny
                    bne -

                    inx                     ; start next run
                    bne --
                    jmp MainTestStart       ; back to begin (the whole block of initial RAM test was obviously added later)

Thorough512Err      ldx #$0a
                    jmp RTBlinkX

;---------------------------------------------------------------------------------------------------------------------------

BlinkOutRamError    eor TestPatterns,x
                    tax
                    and #$fe
                    bne Le267
                    ldx #$08
                    jmp RTBlinkX
                    
Le267               txa
                    and #$fd
                    bne Le271
                    ldx #$07
                    jmp RTBlinkX
                    
Le271               txa
                    and #$fb
                    bne Le27b
                    ldx #$06
                    jmp RTBlinkX
                    
Le27b               txa
                    and #$f7
                    bne Le285
                    ldx #$05
                    jmp RTBlinkX
                    
Le285               txa
                    and #$ef
                    bne Le28f
                    ldx #$04
                    jmp RTBlinkX
                    
Le28f               txa
                    and #$df
                    bne Le299
                    ldx #$03
                    jmp RTBlinkX
                    
Le299               txa
                    and #$bf
                    bne Le2a3
                    ldx #$02
                    jmp RTBlinkX
Le2a3               ldx #$01

RTBlinkX            txs                     ; just using SP as temp here
Le2a6               lda #$01
                    sta $d020
                    sta $d021

                    +Flip_Cass_Port_A
					
                    txa
                    ldx #$7f
                    ldy #$00
Le2b3               dey
                    bne Le2b3
                    dex
                    bne Le2b3
                    tax
                    lda #$00
                    sta $d020
                    sta $d021


                    +Flip_Cass_Port_A
					
                    txa
                    ldx #$7f
                    ldy #$00
Le2c7               dey
                    bne Le2c7
                    dex
                    bne Le2c7
Le2cd               dey
                    bne Le2cd
                    dex
                    bne Le2cd
                    tax
                    dex
                    beq Le2da
                    jmp Le2a6
                    
Le2da               ldx #$00
                    ldy #$00
Le2de               dey
                    bne Le2de
                    dex
                    bne Le2de
Le2e4               dey
                    bne Le2e4
                    dex
                    bne Le2e4
Le2ea               dey
                    bne Le2ea
                    dex
                    bne Le2ea
Le2f0               dey
                    bne Le2f0
                    dex
                    bne Le2f0
                    tsx                     ; restore X reg to "times to flash"
                    jmp Le2a6

;---------------------------------------------------------------------------------------------------------------------------
; Zero Page Test
; This clobbers firstUnusedZP..$00ff
;---------------------------------------------------------------------------------------------------------------------------

Test_ZeroPage       lda #31                 ; arrow left
                    sta ScreenMemStart+ZPMsgOff+13
                    ldx #$13
Le307               lda TestPatterns,x
                    ldy #firstUnusedZP
-                   sta $0000,y
                    iny
                    bne -
                    txa
                    ldx #$00
                    ldy #$00
-                   dey                     ; delay
                    bne -
                    dex
                    bne -
                    tax
                    ldy #firstUnusedZP
-                   lda TestPatterns,x
                    eor $0000,y
                    bne ZP_Error
                    iny
                    bne -
                    dex
                    bpl Le307

                    ldy #$02                ; invert first page twice then check
-                   lda $0000,y
                    tax
                    eor #$ff
                    sta $0000,y
                    lda $0000,y
                    eor #$ff
                    sta $0000,y
                    txa
                    eor $0000,y
                    bne ZP_Error
                    iny
                    bne -

                    lda #$0f                ; "O"
                    sta ScreenMemStart+ZPMsgOff+13
                    lda #$0b                ; "K"
                    sta ScreenMemStart+ZPMsgOff+14
                    lda ColorTextOk
                    sta ColMemStart+ZPMsgOff+13
                    sta ColMemStart+ZPMsgOff+14
                    rts

ZP_Error            tax
                    lda #$02                ; "B"
                    sta ScreenMemStart+ZPMsgOff+13
                    lda #$01                ; "A"
                    sta ScreenMemStart+ZPMsgOff+14
                    lda #$04                ; "D"
                    sta ScreenMemStart+ZPMsgOff+15
                    lda ColorTextBad
                    sta ColMemStart+ZPMsgOff+13
                    sta ColMemStart+ZPMsgOff+14
                    sta ColMemStart+ZPMsgOff+15
                    jmp RamTest_Error_Bit_0
                    
;---------------------------------------------------------------------------------------------------------------------------
; Color Ram Test
;---------------------------------------------------------------------------------------------------------------------------

Test_ColorRam       lda #31                 ; arrow left
                    sta ScreenMemStart+ColMsgOff+13
                    ldx #$00
                    ldy #$d8
                    stx tmp1Ptr
                    sty tmp1PtrHi
                    ldy #$00
Le41b               ldy #$00
                    lda (tmp1Ptr),y
                    pha
                    ldx #$0b
Le422               lda ColorRamTP,x
                    sta (tmp1Ptr),y
                    txa
                    ldx #$00
Le42a               dex
                    bne Le42a
                    tax
                    lda (tmp1Ptr),y
                    and #$0f
                    cmp ColorRamTP,x
                    bne Test_ColorRam_Err
                    dex
                    bpl Le422
                    pla
                    sta (tmp1Ptr),y
                    inc tmp1Ptr
                    bne Le443
                    inc tmp1PtrHi
Le443               lda tmp1PtrHi
                    cmp #$dc
                    bne Le41b
                    lda #$0f                ; "O"
                    sta ScreenMemStart+ColMsgOff+13
                    lda #$0b                ; "K"
                    sta ScreenMemStart+ColMsgOff+14
                    lda ColorTextOk
                    sta ColMemStart+ColMsgOff+13
                    sta ColMemStart+ColMsgOff+14
                    rts
                    
Test_ColorRam_Err   eor ColorRamTP,x
                    tax
                    lda #$02                ; "B"
                    sta ScreenMemStart+ColMsgOff+13
                    lda #$01                ; "A"
                    sta ScreenMemStart+ColMsgOff+14
                    lda #$04                ; "D"
                    sta ScreenMemStart+ColMsgOff+15
                    lda ColorTextBad
                    sta ColMemStart+ColMsgOff+13
                    sta ColMemStart+ColMsgOff+14
                    sta ColMemStart+ColMsgOff+15
                    jmp RamTest_Error_Bit_0

;---------------------------------------------------------------------------------------------------------------------------
; RAM Test First 4 kByte
;---------------------------------------------------------------------------------------------------------------------------

RamTestMsgScrStart  = 40
RamTestLongMsgLen   = 66
RamTestBegin        = RamTestMsgScrStart + RamTestLongMsgLen + 1

Test_RamTest        lda #($3800/$0800*2)    ; VIC-II sees ROM $F000 at $3000:
                    sta $d018               ; show charset from ROM
                    +CopyStr_AX strRamTest, RamTestMsgScrStart, RamTestLongMsgLen

                    ldx #$00
                    ldy #>RamTestBegin
                    stx tmp1Ptr
                    sty tmp1PtrHi
                    ldx passCounterLo
                    inx                     ; avoid seeding PRNG with 0
                    txa
                    +PRNG_Init
                    ldy #<RamTestBegin
Test_RamTest_2      ldx #$13
Test_RamTest_3      lda TestPatterns,x
                    sta (tmp1Ptr),y
                    lda (tmp1Ptr),y
                    eor TestPatterns,x
                    beq +
                    jmp Test_RamTest_Error
+                   dex
                    bpl Test_RamTest_3
                    +PRNG_Generate
                    sta (tmp1Ptr),y         ; store PRNG byte
                    iny                     ; next address
                    bne Test_RamTest_2
                    inc tmp1PtrHi
                    lda tmp1PtrHi
                    cmp #$10
                    bne Test_RamTest_2

                    ; verify PRNG bytes
                    ldx passCounterLo
                    inx
                    txa
                    +PRNG_Init
                    ldy #>RamTestBegin
                    sty tmp1PtrHi
                    ldy #$00
                    sty tmp1Ptr
                    ldy #<RamTestBegin
-                   +PRNG_Generate
                    cmp (tmp1Ptr),y
                    beq +
                    lda #$00
                    jmp Test_RamTest_Error
+                   iny
                    bne -
                    inc tmp1PtrHi
                    lda tmp1PtrHi
                    cmp #$10
                    bne -

                    ; all ok, fix memory clobbering
                    lda VicInit+$18
                    sta $d018               ; switch VIC-II to RAM again
                    +CopyCharSet_AXY
                    jsr SetupTextScreen

                    lda #$0f                ; "O"
                    sta ScreenMemStart+RamMsgOff+13
                    sta ScreenMemStart+ZPMsgOff+13   ; oh well, just restore the ZP/Col "OK"s, too
                    sta ScreenMemStart+ColMsgOff+13
                    lda #$0b                ; "K"
                    sta ScreenMemStart+RamMsgOff+14
                    sta ScreenMemStart+ZPMsgOff+14
                    sta ScreenMemStart+ColMsgOff+14
                    lda ColorTextOk
                    sta ColMemStart+RamMsgOff+13
                    sta ColMemStart+ZPMsgOff+13
                    sta ColMemStart+ColMsgOff+13
                    sta ColMemStart+RamMsgOff+14
                    sta ColMemStart+ZPMsgOff+14
                    sta ColMemStart+ColMsgOff+14
                    jmp BackFromRAMTest

Test_RamTest_Error  ; expects bit errors in A or zero on PRNG check error
                    tax
                    txs                     ; just use S as temp register, stack is unreliable anyways
                    lda VicInit+$18
                    sta $d018               ; switch VIC-II to RAM again
                    +CopyCharSet_AXY        ; do minimal screen fixes after clobbering
                    ldy #$ff
                    jmp SetupTextScreen     ; this will not use RTS because of Y>0
Test_RamTest_Return tsx
                    bne Test_RamTest_Biterr
                    lda #$01                ; "A"
                    sta ScreenMemStart+RamMsgOff+13
                    lda #$04                ; "D"
                    sta ScreenMemStart+RamMsgOff+14
                    lda #$12                ; "R"
                    sta ScreenMemStart+RamMsgOff+15
                    lda #$06                ; "F"
                    sta ScreenMemStart+RamMsgOff+16
                    lda #$01                ; "A"
                    sta ScreenMemStart+RamMsgOff+17
                    lda #$09                ; "I"
                    sta ScreenMemStart+RamMsgOff+18
                    lda #$0c                ; "L"
                    sta ScreenMemStart+RamMsgOff+19
                    lda ColorTextBad
                    sta ColMemStart+RamMsgOff+13
                    sta ColMemStart+RamMsgOff+14
                    sta ColMemStart+RamMsgOff+15
                    sta ColMemStart+RamMsgOff+16
                    sta ColMemStart+RamMsgOff+17
                    sta ColMemStart+RamMsgOff+18
                    sta ColMemStart+RamMsgOff+19
                    jmp LoopUntilDoomsday

Test_RamTest_Biterr lda #$02                ; "B"
                    sta ScreenMemStart+RamMsgOff+13
                    lda #$01                ; "A"
                    sta ScreenMemStart+RamMsgOff+14
                    lda #$04                ; "D"
                    sta ScreenMemStart+RamMsgOff+15
                    lda ColorTextBad
                    sta ColMemStart+RamMsgOff+13
                    sta ColMemStart+RamMsgOff+14
                    sta ColMemStart+RamMsgOff+15
                    
RamTest_Error_Bit_0 txa
                    and #$01
                    beq RamTest_Error_Bit_1
                    lda #$02                ; "B"
                    sta $06a4
                    lda #$01                ; "A"
                    sta $06a5
                    lda #$04                ; "D"
                    sta $06a6
                    lda ColorTextBad
                    sta $daa4
                    sta $daa5
                    sta $daa6
RamTest_Error_Bit_1 txa
                    and #$02
                    beq RamTest_Error_Bit_2
                    lda #$02                ; "B"
                    sta $06a0
                    lda #$01                ; "A"
                    sta $06a1
                    lda #$04                ; "D"
                    sta $06a2
                    lda ColorTextBad
                    sta $daa0
                    sta $daa1
                    sta $daa2
RamTest_Error_Bit_2 txa
                    and #$04
                    beq RamTest_Error_Bit_3
                    lda #$02                ; "B"
                    sta $069c
                    lda #$01                ; "A"
                    sta $069d
                    lda #$04                ; "D"
                    sta $069e
                    lda ColorTextBad
                    sta $da9c
                    sta $da9d
                    sta $da9e
RamTest_Error_Bit_3 txa
                    and #$08
                    beq RamTest_Error_Bit_4
                    lda #$02                ; "B"
                    sta $0698
                    lda #$01                ; "A"
                    sta $0699
                    lda #$04                ; "D"
                    sta $069a
                    lda ColorTextBad
                    sta $da98
                    sta $da99
                    sta $da9a
RamTest_Error_Bit_4 txa
                    and #$10
                    beq RamTest_Error_Bit_5
                    lda #$02                ; "B"
                    sta $0694
                    lda #$01                ; "A"
                    sta $0695
                    lda #$04                ; "D"
                    sta $0696
                    lda ColorTextBad
                    sta $da94
                    sta $da95
                    sta $da96
RamTest_Error_Bit_5 txa
                    and #$20
                    beq RamTest_Error_Bit_6
                    lda #$02                ; "B"
                    sta $0690
                    lda #$01                ; "A"
                    sta $0691
                    lda #$04                ; "D"
                    sta $0692
                    lda ColorTextBad
                    sta $da90
                    sta $da91
                    sta $da92
RamTest_Error_Bit_6 txa
                    and #$40
                    beq RamTest_Error_Bit_7
                    lda #$02                ; "B"
                    sta $068c
                    lda #$01                ; "A"
                    sta $068d
                    lda #$04                ; "D"
                    sta $068e
                    lda ColorTextBad
                    sta $da8c
                    sta $da8d
                    sta $da8e
RamTest_Error_Bit_7 txa
                    and #$80
                    beq LoopUntilDoomsday
                    lda #$02                ; "B"
                    sta $0688
                    lda #$01                ; "A"
                    sta $0689
                    lda #$04                ; "D"
                    sta $068a
                    lda ColorTextBad
                    sta $da88
                    sta $da89
                    sta $da8a

LoopUntilDoomsday   inc $d020
                    jmp LoopUntilDoomsday   ; NO CARRIER

;---------------------------------------------------------------------------------------------------------------------------
; Sound Test
;---------------------------------------------------------------------------------------------------------------------------

Test_SoundTest      lda #31                 ; arrow left
                    sta ScreenMemStart+SoundMsgOff+13
                    lda #$14
                    sta $d418
                    lda #$00
                    sta $d417
                    lda #$3e
                    sta $d405
                    lda #$ca
                    sta $d406
                    lda #$00
                    sta $d412
                    lda #$03                ; cycle through 4 waveforms
TestNextWaveForm    pha                     ; save waveform index on stack

                    ldx #$06                ; play 7 notes
PlayVoice1          lda SidFreqV1Hi,x       ; on voice #1
                    sta $d401
                    lda SidFreqV1Lo,x
                    sta $d400

                    pla                     ; restore waveform index         
                    tay                     ; from stack
                    lda SidPWidthLo,y       ; load pulse width value LO for index no. Y
                    sta $d402               ; set pulse width LO              
                    lda SidPWidthHi,y       ; load pulse width value HI for index no. Y
                    sta $d403               ; set pulse width HI              
                    lda SidWaveForms,y      ; load waveform value for index no. Y
                    sta $d404               ; set waveform
                    tya                     ; save waveform index
                    pha                     ; on stack
                    
                    lda #$6a
                    jsr SoundDelayLoop
                    lda #$00
                    sta $d404
                    lda #$00
                    jsr SoundDelayLoop
                    dex
                    bne PlayVoice1
                    lda #$00
                    sta $d417
                    lda #$18
                    sta $d418
                    lda #$3e
                    sta $d40c
                    lda #$ca
                    sta $d40d

                    ldx #$06                ; play 7 notes
PlayVoice2          lda SidFreqV2Hi,x       ; on voice #2
                    sta $d408
                    lda SidFreqV2Lo,x
                    sta $d407
                    pla                     ; restore waveform index         
                    tay                     ; from stack
                    lda SidPWidthLo,y       ; load pulse width value LO for index no. Y
                    sta $d409
                    lda SidPWidthHi,y       ; load pulse width value HI for index no. Y
                    sta $d40a
                    lda SidWaveForms,y      ; load waveform value for index no. Y
                    sta $d40b
                    tya                     ; save waveform index         
                    pha                     ; on stack
                    lda #$6a
                    jsr SoundDelayLoop
                    lda #$00
                    sta $d40b
                    lda #$00
                    jsr SoundDelayLoop
                    dex
                    bne PlayVoice2
                    lda #$00
                    sta $d417
                    lda #$1f
                    sta $d418
                    lda #$3e
                    sta $d413
                    lda #$ca
                    sta $d414

                    ldx #$06                ; play 7 notes
PlayVoice3          lda SidFreqV3Hi,x       ; on voice #3
                    sta $d40f
                    lda SidFreqV3Lo,x
                    sta $d40e
                    pla
                    tay
                    lda SidPWidthLo,y       ; load pulse width value LO for index no. Y
                    sta $d410
                    lda SidPWidthHi,y       ; load pulse width value HI for index no. Y
                    sta $d411
                    lda SidWaveForms,y      ; load waveform value for index no. Y
                    sta $d412
                    tya
                    pha
                    lda #$6a
                    jsr SoundDelayLoop
                    lda #$00
                    sta $d412
                    lda #$00
                    jsr SoundDelayLoop
                    dex
                    bne PlayVoice3
                    pla
                    tay
                    dey
                    tya
                    bmi SoundTestComplete
                    jmp TestNextWaveForm    ; start over with next waveform
                    
SoundTestComplete   lda #$00                ; shut down SID
                    sta $d418
                    rts

;---------------------------------------------------------------------------------------------------------------------------
; Delay Loop for Sounds
;---------------------------------------------------------------------------------------------------------------------------

SoundDelayLoop      cmp #$00
                    beq SoundDelayLoopCpl
                    tay
                    txa
                    pha
                    tya
                    tax
SoundDelayLoop_1    ldy #$ff
SoundDelayLoop_2    dey
                    bne SoundDelayLoop_2
                    dex
                    bne SoundDelayLoop_1
                    pla
                    tax
SoundDelayLoopCpl   rts
                    
;---------------------------------------------------------------------------------------------------------------------------
; Update TOD1 display
;---------------------------------------------------------------------------------------------------------------------------

UpdateTod1Display   +Flip_Cass_Port_A
					
                    lda $dc0b               ; test for PM flag
                    clc
                    asl
                    bcc OutText_TOD1_AM
                    
                    lda #$10                ; "P"
                    sta $07db
                    lda #$0d                ; "M"
                    sta $07dc
                    clc
                    bcc Skip_TOD1_AM
                    
OutText_TOD1_AM     lda #$01                ; "A"
                    sta $07db
                    lda #$0d                ; "M"
                    sta $07dc

Skip_TOD1_AM        lda $dc0b               ; read hours
                    and #$7f                ; only lower 7 bits, PM flag already tested before
                    ldy #$01                ; two digits
                    bne Le732
                    
Le700               sta $07d3
                    stx $07d4
                    lda #$2d                ; "-"
                    sta $07d5
                    lda $dc0a
                    ldy #$02
                    bne Le732
Le712               sta $07d6
                    stx $07d7
                    lda #$2d                ; "-"
                    sta $07d8
                    lda $dc09
                    ldy #$03
                    bne Le732
Le724               sta $07d9
                    stx $07da
                    lda $dc08
                    clc
                    bcc UpdateTod2Display
                    ldy #$00

Le732               pha                     ; save value
                    sty $10                 
                    ldy #$04
                    bne Le741
Le739               ldy $10
                    tax
                    pla
                    lsr
                    lsr
                    lsr
                    lsr
Le741               and #$0f                ; ones digit
                    cmp #$0a
                    bmi Le74c
                    sec
                    sbc #$09
                    bne Le74e
Le74c               ora #$30
Le74e               cpy #$01
                    beq Le700
                    cpy #$02
                    beq Le712
                    cpy #$03
                    beq Le724
                    cpy #$04
                    beq Le739
                    cpy #$05
                    beq Le792
                    cpy #$06
                    beq Le7a4
                    cpy #$07
                    beq Le7b6
                    rts
                    
;---------------------------------------------------------------------------------------------------------------------------
; Update TOD2 display
;---------------------------------------------------------------------------------------------------------------------------

UpdateTod2Display   lda $dd0b
                    clc
                    asl
                    bcc Le77f
                    lda #$10
                    sta $07e6
                    lda #$0d
                    sta $07e7
                    clc
                    bcc Le789
Le77f               lda #$01
                    sta $07e6
                    lda #$0d
                    sta $07e7
Le789               lda $dd0b
                    and #$7f
                    ldy #$05
Le790               bne Le732
Le792               sta $07de
                    stx $07df
                    lda #$2d
                    sta $07e0
                    lda $dd0a
                    ldy #$06
                    bne Le790
Le7a4               sta $07e1
                    stx $07e2
                    lda #$2d
                    sta $07e3
                    lda $dd09
                    ldy #$07
                    bne Le790
Le7b6               sta $07e4
                    stx $07e5
                    lda $dd08
                    rts

;---------------------------------------------------------------------------------------------------------------------------
; Integrated character set, 63 chars standard PETSCII
; Chars 34..39 replaced with PETSCII for drawing the frame.
;---------------------------------------------------------------------------------------------------------------------------

                    * = $f800       ; fixed position as we switch to ROM charset occasionally

:CharSet            !hex 3c 66 6e 6e 60 62 3c 00        ; @
                    !hex 18 3c 66 7e 66 66 66 00        ; A
                    !hex 7c 66 66 7c 66 66 7c 00        ; B
                    !hex 3c 66 60 60 60 66 3c 00        ; C
                    !hex 78 6c 66 66 66 6c 78 00        ; D
                    !hex 7e 60 60 78 60 60 7e 00        ; E
                    !hex 7e 60 60 78 60 60 60 00        ; F
                    !hex 3c 66 60 6e 66 66 3c 00        ; G
                    !hex 66 66 66 7e 66 66 66 00        ; H
                    !hex 3c 18 18 18 18 18 3c 00        ; I
                    !hex 1e 0c 0c 0c 0c 6c 38 00        ; J
                    !hex 66 6c 78 70 78 6c 66 00        ; K
                    !hex 60 60 60 60 60 60 7e 00        ; L
                    !hex 63 77 7f 6b 63 63 63 00        ; M
                    !hex 66 76 7e 7e 6e 66 66 00        ; N
                    !hex 3c 66 66 66 66 66 3c 00        ; O
                    !hex 7c 66 66 7c 60 60 60 00        ; P
                    !hex 3c 66 66 66 66 3c 0e 00        ; Q
                    !hex 7c 66 66 7c 78 6c 66 00        ; R
                    !hex 3c 66 60 3c 06 66 3c 00        ; S
                    !hex 7e 18 18 18 18 18 18 00        ; T
                    !hex 66 66 66 66 66 66 3c 00        ; U
                    !hex 66 66 66 66 66 3c 18 00        ; V
                    !hex 63 63 63 6b 7f 77 63 00        ; W
                    !hex 66 66 3c 18 3c 66 66 00        ; X
                    !hex 66 66 66 3c 18 18 18 00        ; Y
                    !hex 7e 06 0c 18 30 60 7e 00        ; Z
                    !hex 3c 30 30 30 30 30 3c 00        ; [
                    !hex 0e 10 30 fe 30 60 ff 00        ; <pound symbol>
                    !hex 3c 0c 0c 0c 0c 0c 3c 00        ; ]
                    !hex 00 18 3c 7e 18 18 18 18        ; <arrow up>
                    !hex 00 10 30 7f 7f 30 10 00        ; <arrow left>
                    !hex 00 00 00 00 00 00 00 00        ; <space>
                    !hex 18 18 18 18 00 00 18 00        ; !
                    !hex 00 00 00 07 0f 1c 18 18        ; <frame upper left corner>
                    !hex 00 00 00 e0 f0 38 18 18        ; <frame upper right corner>
                    !hex 18 18 1c 0f 07 00 00 00        ; <frame lower left corner>
                    !hex 18 18 38 f0 e0 00 00 00        ; <frame lower right corner>
                    !hex 00 00 00 ff ff 00 00 00        ; <frame horizontal line>
                    !hex 18 18 18 18 18 18 18 18        ; <frame vertical line>
                    !hex 0c 18 30 30 30 18 0c 00        ; (
                    !hex 30 18 0c 0c 0c 18 30 00        ; )
                    !hex 00 66 3c ff 3c 66 00 00        ; *
                    !hex 00 18 18 7e 18 18 00 00        ; +
                    !hex 00 00 00 00 00 18 18 30        ; ,
                    !hex 00 00 00 7e 00 00 00 00        ; -
                    !hex 00 00 00 00 00 18 18 00        ; .
                    !hex 00 03 06 0c 18 30 60 00        ; /
                    !hex 3c 66 6e 76 66 66 3c 00        ; 0
                    !hex 18 18 38 18 18 18 7e 00        ; 1
                    !hex 3c 66 06 0c 30 60 7e 00        ; 2
                    !hex 3c 66 06 1c 06 66 3c 00        ; 3
                    !hex 06 0e 1e 66 7f 06 06 00        ; 4
                    !hex 7e 60 7c 06 06 66 3c 00        ; 5
                    !hex 3c 66 60 7c 66 66 3c 00        ; 6
                    !hex 7e 66 0c 18 18 18 18 00        ; 7
                    !hex 3c 66 66 3c 66 66 3c 00        ; 8
                    !hex 3c 66 66 3e 06 66 3c 00        ; 9
                    !hex 00 00 00 18 00 00 18 00        ; :
                    !hex 00 00 18 00 00 18 18 30        ; ;
                    !hex 0e 18 30 60 30 18 0e 00        ; <
                    !hex 00 00 7e 00 7e 00 00 00        ; =
                    !hex 70 18 0c 06 0c 18 70 00        ; >
                    !hex 3c 66 06 0c 18 00 18 00        ; ?

;---------------------------------------------------------------------------------------------------------------------------
; Strings
;---------------------------------------------------------------------------------------------------------------------------

                    !align 255,0  ; not strictly necessary

strCaption          !scr "github.com/c1570/c64-dead-test  20250719" ; 40 chars fixed text (one line)
strCount            !scr "count"                                    ;  5 chars fixed text
strZeroPage         !scr "zero page"                                ;  9 chars fixed text
strRamTest          !scr "ram test 4kb is running, screen will be restored in a few seconds."
strColorRam         !scr "color ram"                                ;  9 chars fixed text
strSoundTest        !scr "sound test"                               ; 10 chars fixed text

;---------------------------------------------------------------------------------------------------------------------------
; Constants and Tables
;---------------------------------------------------------------------------------------------------------------------------

ColorTextOk         !hex 05     ; green
ColorTextBad        !hex 02     ; red

TestPatterns        !hex 00 55 aa ff 01 02 04 08 10 20 40 80 fe fd fb f7 
                    !hex ef df bf 7f    

ColorRamTP          !hex 00 05 0a 0f 01 02 04 08 0e 0d 0b 07 

VicInit             !hex 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
                    !hex 00 1b 00 00 00 00 08 00 12 00 00 00 00 00 00 00 
                    !hex 03 01 00 00 00 00 00 00 00 00 00 00 00 00 00 

Cia1Init            !hex 00 00 00 00 00 

Cia2Init            !hex 00 00 00 00 80 

SidFreqV1Hi         !hex 11 15 19 22 19 15 11 

SidFreqV1Lo         !hex 25 9a b1 4b b1 9a 25 

SidFreqV2Hi         !hex 22 2b 33 44 33 2b 22 

SidFreqV2Lo         !hex 4b 34 61 95 61 34 4b 

SidFreqV3Hi         !hex 44 56 66 89 66 56 44 

SidFreqV3Lo         !hex 95 69 c2 2b c2 69 95 

SidWaveForms        !hex 81 45 25 11

SidPWidthLo         !hex 00 00 00 00
                    
SidPWidthHi         !hex 00 08 00 00

StatusHeader        !scr 34, "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&", 35
                    
                    ;     123456789.123456789.123456789.123456789."
StatusText          !scr 39, "bit    d7  d6  d5  d4  d3  d2  d1  d0 ", 39
                    !scr 39, "status ok  ok  ok  ok  ok  ok  ok  ok ", 39
                    !scr 39, "                                      ", 39
                    !scr 39, " 4164  u12 u24 u11 u23 u10 u22 u9  u21", 39
                    !scr 39, "250466 u9  u9  u9  u9  u10 u10 u10 u10", 39
                    !scr 39, "250469 u11 u11 u11 u11 u10 u10 u10 u10", 39
                    !hex ff

StatusColor         !hex 02 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 02
                    !hex 02 06 06 06 06 06 06 06 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 02
                    !hex 02 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 02
                    !hex 02 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 02
                    !hex 02 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 02
                    !hex 02 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 02
                    !hex ff 

StatusFooter        !scr 36, "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&", 37

                    *= $fdf0                            ; Interrupt service routine
                    
:ISR                rti

;---------------------------------------------------------------------------------------------------------------------------
; CPU vectors
;---------------------------------------------------------------------------------------------------------------------------

                    *= $fffa	

                    !word Reset_Handler
                    !word Reset_Handler
                    !word ISR
