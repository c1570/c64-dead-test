;---------------------------------------------------------------------------------------------------------------------------
; "C-64 DEAD TEST"
; https://github.com/c1570/c64-dead-test
;
; Initially disassembled from original Dead Test 781220 - copyright, credits, status unknown.
; Comments, "improvements", fixes, etc., up to 006 by kinzi @ Forum64, see https://www.forum64.de/
; More recent changes authors see Git
;---------------------------------------------------------------------------------------------------------------------------

                    !to "dead_test.bin", plain
                    !convtab scr

;---------------------------------------------------------------------------------------------------------------------------
;
; Memory layout for "Dead Test"
;
; $0400..$07FF = screen RAM
; $0800..$09FF = char set in RAM
; $0A00..$0FFF = Sound/RAM 64k/Keyboard/ROM CRC code (additional tests are run only in RAM/KERNAL mode)
; $D800..$DBFF = color RAM
; $D000..$DFFF = I/O
; $F800..$F9FF = char set in ROM
;
;---------------------------------------------------------------------------------------------------------------------------
;
; CPU I/O Port:
;
; P0 - "/LORAM"                 - no impact in Ultimax Mode
; P1 - "/HIRAM"                 - no impact in Ultimax Mode
; P2 - "/CHAREN"                - no impact in Ultimax Mode
; P3 - "CASS WRITE" (Pin "E/5") - bit 3 (dec 8)
; P4 - "CASS SENSE" (Pin "F/6") - bit 4 (dec 16) 
; P5 - "CASS MOTOR" (Pin "C/3") - bit 5 (dec 32)
;
; P3/P4 could be used for status LEDs
;
; In the 586220 harness CASS_WRITE and CASS_MOTOR are interconnected through resistors, CASS_READ and CASS_SENSE are
; directly connected together. So CASS_SENSE and CASS_MOTOR could be used for LEDs (and _will_ be in Check64 V2.0).
;
;---------------------------------------------------------------------------------------------------------------------------
;
; Using startup colors like in Amiga self diag at startup ...
;
; Startup               = light grey             CASS MOTOR = 1 ; CASS SENSE = 1 (CPU default)
;
; Initial RAM Test using test patterns 00 55 aa ff 01 02 04 08 10 20 40 80 fe fd fb f7 ef df bf 7f
;
; Pattern 00 "00000000"   -> light grey		 CASS MOTOR = 0 ; CASS SENSE = 0 - inverted on every single next step
; Pattern 55 "01010101"   -> light blue
; Pattern aa "10101010"   -> light green
; Pattern ff "11111111"   -> grey
; Pattern 01 "00000001"   -> dark grey
; Pattern 02 "00000010"   -> light red
; Pattern 04 "00000100"   -> brown
; Pattern 08 "00001000"   -> orange
; Pattern 10 "00010000"   -> yellow
; Pattern 20 "00100000"   -> blue
; Pattern 40 "01000000"   -> green
; Pattern 80 "10000000"   -> purple
; Pattern fe "10000000"   -> purple
; Pattern fd "11111110"   -> cyan
; Pattern fb "11111101"   -> red
; Pattern f7 "11111011"   -> white
; Pattern ef "11110111"   -> black
; Pattern df "11101111"   -> light grey
; Pattern bf "11011111"   -> light blue
; Pattern 7f "10111111"   -> light green
;
; Main Test             = (standard)             CASS MOTOR = 0 ; CASS SENSE = 1 (swap every TOD clock update)
;
; On RAM test errors both LEDs just blink in sync with the border screen color
;
;---------------------------------------------------------------------------------------------------------------------------

; these are all zeropage locations that get used in the code
passCounterLo  = $02
passCounterHi  = passCounterLo + 1
tmp1Ptr        = passCounterHi + 1
tmp1PtrHi      = tmp1Ptr + 1

tmp2Ptr        = tmp1PtrHi + 1    ; don't use along with prng
tmp2PtrHi      = tmp2Ptr + 1
prngX          = tmp2Ptr
prngY          = tmp2PtrHi

prngZ          = prngY + 1
prngA          = prngZ + 1
prngT          = prngA + 1

firstUnusedZP  = prngT + 1

crclo    = $7000         ; Two 256-byte tables for quick lookup
crchi    = crclo + $0100
crc_tmp  = prngZ
crc      = prngA         ; current CRC
crc2     = crc + 1

CharSetInRamStart    = $0800  ; charset uses 512 bytes
TestsInRamStart      = $0a00  ; Location to copy tests running from RAM to
TestsInRamEnd        = $1000
RelocatableCodeStart = $ea00

ScreenMemStart = $0400
ColMemStart = $d800

ZPMsgOff = 80
ColMsgOff = 120
RamMsgOff = 160
Cia1MsgOff = 200
SoundMsgOff = 240
Ram64MsgOff = 280

RamTestMsgScrStart  = 40
RamTestLongMsgLen   = 66

ColorTextOk         = 5       ; green
ColorTextBad        = 2       ; red

;---------------------------------------------------------------------------------------------------------------------------
; PRNG routine
;---------------------------------------------------------------------------------------------------------------------------

; the following is a port of rng-4261412736 by Edward Rosten, https://github.com/edrosten/8bit_rng
; based on the xorshift algorithm

; implemented as macros to not clobber the stack

!macro PRNG_Init {             ; init PRNG using A
                    sta prngA
                    lda #$00
                    sta prngX
                    sta prngY
                    sta prngZ
}

!macro PRNG_Generate {         ; returns one new PRNG byte in A, doesn't clobber any other register
                    lda prngX
                    rol
                    rol
                    rol
                    rol
                    and #$f0
                    eor prngX
                    sta prngT  ; t = x ^ (x << 4)
                    lda prngY
                    sta prngX  ; x = y
                    lda prngZ
                    sta prngY  ; y = t
                    lda prngA
                    sta prngZ  ; z = a
                    eor prngT
                    sta prngA  ; a = z ^ t ...
                    lda prngZ
                    clc
                    ror
                    eor prngA
                    sta prngA  ; ... ^ (z >> 1)
                    lda prngT
                    clc
                    rol
                    eor prngA
                    sta prngA  ; ... ^ (t << 1)
}

;---------------------------------------------------------------------------------------------------------------------------
; other macros
;---------------------------------------------------------------------------------------------------------------------------

!macro Flip_Cass_Port_A { ; flip cassette port lines, clobbers A
                    lda #$30                ; xxMSWxxx : CASS MOTOR = "M",   CASS SENSE = "S",   CASS WRITE = "W"
                    eor $01                 ; 00110000 ; flip CASS MOTOR and CASS SENSE
                    sta $01
}

!macro CopyCharSet_AY { ; copy charset from ROM to RAM, clobbers A,Y
                    ldy #$00
-                   lda CharSet,y
                    sta CharSetInRamStart,y
                    lda CharSet+$0100,y
                    sta CharSetInRamStart+$0100,y
                    iny
                    bne -
}

!macro CopyStr_AX .sourcePtr, .destPtr, .len {
                    ldx #(.len - 1)
-                   lda .sourcePtr,x
                    sta .destPtr,x
                    dex
                    bpl -
}

!macro WriteStr_A .screenStart, .offset, .color, @str {
                    @length = len(@str)
                    !for @index, 0, @length - 1 {
                      lda #@str[@index]
                      sta .screenStart + .offset + @index
                    }
                    lda #.color
                    !for @index, 0, @length - 1 {
                      sta ColMemStart + .offset + @index
                    }
}

!macro WriteStrYOff_A .screenStart, .offset, .color, @str {
                    @length = len(@str)
                    !for @index, 0, @length - 1 {
                      lda #@str[@index]
                      sta .screenStart + .offset + @index, y
                    }
                    lda #.color
                    !for @index, 0, @length - 1 {
                      sta ColMemStart + .offset + @index, y
                    }
}

!macro UltimaxMode_A { ; sets carry if in ultimax mode, clobbers A (and $bfff/$bffe)
                    lda $01
                    and #$fe   ; try to enable RAM at $A000-$BFFF
                    sta $01
                    lda #$55
                    sta $bfff
                    lda #$ff
                    sta $bffe
                    lda #$55
                    cmp $bfff
                    bne ++     ; seeing LOROM
                    lda #$ff
                    cmp $bffe
                    bne ++     ; seeing LOROM
                    lda $01
                    ora #$01
                    sta $01
                    clc
                    bcc +
++                  lda $01
                    ora #$01
                    sta $01
                    sec
+
}

!macro CRCUpdate_X { ; Quick CRC computation with lookup tables, clobbers X
         eor crc+1
         tax
         lda crc
         eor crchi,x
         sta crc+1
         lda crclo,x
         sta crc
}

;---------------------------------------------------------------------------------------------------------------------------
; start of code
;---------------------------------------------------------------------------------------------------------------------------


                    *= $e000

Reset_Handler       sei
                    ldx #$ff                
                    stx $d020               ; patch by kinzi: set screen color to different color (from black) as early as possible
                    txs
                    cld

                    lda #$c7                ; xx000xxx : CASS MOTOR = 0,   CASS SENSE = 0,   CASS WRITE = 0
                    sta $01
                    lda #$37                ; xx110xxx : CASS MOTOR = out, CASS SENSE = out, CASS WRITE = in
                    sta $00
                    
                    jmp IntegrityTest       ; jump to ROM integrity test
                    
;---------------------------------------------------------------------------------------------------------------------------
; Main Test
; Stack and ZP have tested okay in initial RAM test, so we're free to use those from here on.
; Still, keep testing and be defensive - problems may occur once the machine has warmed up
;---------------------------------------------------------------------------------------------------------------------------

MainTestStart       ldx #$04
-                   lda Cia1Init,x          ; CIA TOD init
                    sta $dc07,x
                    lda Cia2Init,x
                    sta $dd07,x
                    dex
                    bne -

CiaRegInit2         lda #$08                ; CIA Timer B Control: Oneshot mode
                    sta $dc0f
                    sta $dd0f
                    lda #$48                ; CIA1 Timer A Control: Oneshot mode, SP is output
                    sta $dc0e
                    lda #$08                ; CIA2 Timer A Control: Oneshot mode
                    sta $dd0e

                    ldx #$00
                    stx passCounterLo
                    stx passCounterHi

MainTestLoop        +Flip_Cass_Port_A
                    ldx #$2f                ; VIC register init
-                   lda VicInit,x
                    sta $d000,x
                    dex
                    bpl -

                    ldy #$00                ; flag for SetupTextScreen to use RTS
                    jsr SetupTextScreen
                    jsr UpdateTod1Display
                    jsr Test_ZeroPage
                    +Flip_Cass_Port_A
                    jsr UpdateTod1Display
                    jsr Test_ColorRam
                    +Flip_Cass_Port_A
                    jsr UpdateTod1Display

                    ; RAM test code is kept small in case it's running from RAM
                    +UltimaxMode_A
                    bcc +
                    lda #($3800/$0800*2)    ; VIC-II sees ROM $F000 at $3000 in Ultimax mode
                    bcs ++
+                   lda #($1000/$0800*2)    ; VIC-II sees CharROM at $1000 in normal mode
++                  sta $d018               ; show charset from ROM
                    +CopyStr_AX strRamTest, RamTestMsgScrStart, RamTestLongMsgLen
                    jmp Test_RamTest        ; Clobbers everything but the very first ZP bytes so don't use JSR
BackFromRAMTest     +CopyCharSet_AY

                    jsr UpdateTod1Display
                    jsr Test_Cia1Test
                    jsr Test_RunTestsFromRam
                    jmp MainTestLoop


;---------------------------------------------------------------------------------------------------------------------------
; (Initial) Screen Setup
; NOTE! If this is called with Y>0, it's not using RTS to exit but JMP Test_RamTest_Return
;---------------------------------------------------------------------------------------------------------------------------

SetupTextScreen     tya
                    tax
                    +CopyCharSet_AY
                    txa
                    tay
                    ldx #$00                ; clear screen following
ClearScreen_1       lda #$20
                    sta $0400,x
                    sta $0500,x
                    sta $0600,x
                    sta $0700,x
                    lda #$06                ; set char color on whole screen
                    sta $d800,x
                    sta $d900,x
                    sta $da00,x
                    sta $db00,x
                    inx
                    bne ClearScreen_1

OutText_Header      ldx #$27                ; 40 chars (header)
-                   lda StatusHeader,x      ; fetch text
                    sta $0630,x             ; store to screen RAM
                    lda #ColorTextBad       ; RED color
                    sta $da30,x             ; fill color RAM
                    dex
                    bpl -

                    +CopyStr_AX strZeroPage, ScreenMemStart+ZPMsgOff, 9
                    +CopyStr_AX strColorRam, ScreenMemStart+ColMsgOff, 9
                    +CopyStr_AX strRamTest, ScreenMemStart+RamMsgOff, 11
                    +CopyStr_AX strCia1Test, ScreenMemStart+Cia1MsgOff, 12
                    +CopyStr_AX strSoundTest, ScreenMemStart+SoundMsgOff, 10
                    
OutText_Status      ldx #$00                ; output a string terminated by "FF"
-                   lda StatusText,x        ; fetch text
                    cmp #$ff                ; eot flag detected?
                    beq OutColor_Status     ; yes, continue
                    sta $0658,x             ; no, store to screen RAM
                    inx
                    jmp -                   ; loop on
                    
OutColor_Status     ldx #$00                ; write correct colors to color RAM, values are terminated by "FF"
-                   lda StatusColor,x       ; fetch color
                    cmp #$ff                ; eot flag detected?
                    beq OutText_Footer      ; yes, continue
                    sta $da58,x             ; no, store to color RAM
                    inx
                    jmp -                   ; loop on
                    
OutText_Footer      ldx #$27                ; 40 chars (footer)
OutText_Footer_1    lda StatusFooter,x
                    sta $0748,x
                    lda #ColorTextBad       ; RED color
                    sta $db48,x             ; fill color RAM
                    dex
                    bpl OutText_Footer_1

OutText_Caption     ldx #$27
OutText_Caption_1   lda strCaption,x        ; write program title to screen
                    sta ScreenMemStart,x
                    dex
                    bpl OutText_Caption_1
                    
OutText_Count       ldx #$04
OutText_Count_1     lda strCount,x          ; write "COUNT"
                    sta ScreenMemStart+$03c0,x
                    dex
                    bpl OutText_Count_1
                    
                    lda passCounterLo       ; output counter digit 1
                    and #$0f
                    ora #$30
                    sta $07c9
                    
                    lda passCounterLo       ; output counter digit 2
                    lsr
                    lsr
                    lsr
                    lsr
                    and #$0f
                    ora #$30
                    sta $07c8
                    
                    lda passCounterHi       ; output counter digit 3
                    and #$0f
                    ora #$30
                    sta $07c7
                    
                    lda passCounterHi       ; output counter digit 4
                    lsr
                    lsr
                    lsr
                    lsr
                    and #$0f
                    ora #$30
                    sta $07c6

                    cpy #$00
                    beq +
                    jmp Test_RamTest_Return
+                   rts

;---------------------------------------------------------------------------------------------------------------------------
; Initial ROM Integrity Test
;---------------------------------------------------------------------------------------------------------------------------

IntegrityTest       lda #$00
                    ldx #$10                ; repeat checksum test 16 times
--                  ldy #$00
-                   !for Iter, 0, 31 { eor $e000 + Iter * $0100,y }
                    iny
                    bne -
                    cmp #$00                ; ROMChecksum is added in build process
                    beq +
IntegrityError      ldx #15
                    jmp RTBlinkX
+                   dex
                    bne -
; just fall through to next test

;---------------------------------------------------------------------------------------------------------------------------
; Initial RAM Addressing Test
; This reads one arbitrary address ($0b55 in this case) then overwrites all other RAM with its complement
; then rechecks the arbitrary address. If it's been changed by the other writes, there's a problem with
; addressing (or memory is unstable in general).
;---------------------------------------------------------------------------------------------------------------------------

InitialRamAddrTest  lda $0b55
                    eor #$ff
                    ldy #$00
-                   cpy #$02
                    bcc +
                    sta $0000,y
+                   !for Iter, 1, 15 { !if Iter != $b { sta $0000 + Iter * $0100,y } }
                    cpy #$55
                    beq +
                    sta $0b00,y
+                   iny
                    bne -
                    eor #$ff
                    cmp $0b55
                    beq InitialRamTest
InitialRamAddrErr   ; found an error; signal to the user for a few secs
                    lda #2                  ; red
                    ldx #50                 ; blink 50 times
--                  txs
                    ldx #0
                    ldy #0
                    sta $d020
-                   dex
                    bne -
                    dey
                    bne -
                    eor #4                  ; red<->blue
                    tay                     ; save color in Y
                    +Flip_Cass_Port_A
                    tya                     ; restore color to A
                    tsx
                    dex
                    bne --
                    dex
                    txs                     ; reinit SP, then fall through to next test

;---------------------------------------------------------------------------------------------------------------------------
; Initial RAM Test
;---------------------------------------------------------------------------------------------------------------------------

InitialRamTest      ldx #$15                ; 22 test patterns
                    ldy #$00
NextTestPattern     lda TestPatterns,x      ; fetch test TestPattern no. x
-                   sta $0100,y             ; write to RAM pages
                    sta $0200,y
                    sta $0300,y
                    sta $0400,y
                    sta $0500,y
                    sta $0600,y
                    sta $0700,y
                    sta $0800,y
                    sta $0900,y
                    sta $0a00,y
                    sta $0b00,y
                    sta $0c00,y
                    sta $0d00,y
                    sta $0e00,y
                    sta $0f00,y
                    iny
                    bne -

                    dec $d020               ; activity control
                    +Flip_Cass_Port_A
					
                    txa
                    ldx #$00
                    ldy #$00            
InitRamTest_Delay   dey                     ; delay 256 * 5 cycles = 1.25 ms
                    bne InitRamTest_Delay
                    dex                     ; delay 256 times = about 80 ms
                    bne InitRamTest_Delay
                    tax

ReCheckTestPattern  lda $0100,y             ; now re-read RAM pages and compare with stored values
                    cmp TestPatterns,x
                    bne ErrorHandler        ; on error branch to error handler
                    lda $0200,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0300,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0400,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0500,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0600,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0700,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0800,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0900,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0a00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0b00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0c00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0d00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0e00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    lda $0f00,y
                    cmp TestPatterns,x
                    bne ErrorHandler
                    iny
                    beq PatternComplete     ; already looped through whole RAM page?
                    jmp ReCheckTestPattern  ; no -> loop on
                    
ErrorHandler        jmp BlinkOutRamError    ; error handler for RAM Test errors
                    
PatternComplete     dex                     ; no errors, continue with next pattern
                    bmi Thorough512Test     ; all patterns tested?
                    ldy #$00                ; no
                    jmp NextTestPattern     ; run RAM test with next pattern
                    
Thorough512Test     ldx #$00                ; do a slightly more thorough check on ZP/stack
--                  ldy #$02
                    stx $d020
-                   txa
                    sta $0000,y             ; write 0,1,2,3,4... to $0002... (in run 0)
                    eor #$55                ; EOR to make sure we detect broken A8
                    sta $0100,y             ; write $55,$54,$57,$56,$51... to $0102...
                    inx
                    iny
                    bne -

                    sty $0202               ; write invalid data to untested area:
                    sty $0402               ; should find stuck address lines
                    sty $0802
                    sty $1002
                    sty $2002
                    sty $4002
                    sty $8002

                    ldy #$02
                    inx                     ; roll over X to its initial value
                    inx
-                   txa
                    cmp $0000,y
                    bne Thorough512Err
                    eor #$55
                    cmp $0100,y
                    bne Thorough512Err
                    inx
                    iny
                    bne -

                    inx                     ; start next run
                    bne --
                    jmp MainTestStart       ; back to begin (the whole block of initial RAM test was obviously added later)

Thorough512Err      ldx #$0a
                    jmp RTBlinkX

;---------------------------------------------------------------------------------------------------------------------------

BlinkOutRamError    eor TestPatterns,x
                    tax
                    and #$fe
                    bne Le267
                    ldx #$08
                    jmp RTBlinkX
                    
Le267               txa
                    and #$fd
                    bne Le271
                    ldx #$07
                    jmp RTBlinkX
                    
Le271               txa
                    and #$fb
                    bne Le27b
                    ldx #$06
                    jmp RTBlinkX
                    
Le27b               txa
                    and #$f7
                    bne Le285
                    ldx #$05
                    jmp RTBlinkX
                    
Le285               txa
                    and #$ef
                    bne Le28f
                    ldx #$04
                    jmp RTBlinkX
                    
Le28f               txa
                    and #$df
                    bne Le299
                    ldx #$03
                    jmp RTBlinkX
                    
Le299               txa
                    and #$bf
                    bne Le2a3
                    ldx #$02
                    jmp RTBlinkX
Le2a3               ldx #$01

RTBlinkX            txs                     ; just using SP as temp here
Le2a6               lda #$01
                    sta $d020
                    sta $d021

                    +Flip_Cass_Port_A
					
                    txa
                    ldx #$7f
                    ldy #$00
Le2b3               dey
                    bne Le2b3
                    dex
                    bne Le2b3
                    tax
                    lda #$00
                    sta $d020
                    sta $d021


                    +Flip_Cass_Port_A
					
                    txa
                    ldx #$7f
                    ldy #$00
Le2c7               dey
                    bne Le2c7
                    dex
                    bne Le2c7
Le2cd               dey
                    bne Le2cd
                    dex
                    bne Le2cd
                    tax
                    dex
                    beq Le2da
                    jmp Le2a6
                    
Le2da               ldx #$00
                    ldy #$00
Le2de               dey
                    bne Le2de
                    dex
                    bne Le2de
Le2e4               dey
                    bne Le2e4
                    dex
                    bne Le2e4
Le2ea               dey
                    bne Le2ea
                    dex
                    bne Le2ea
Le2f0               dey
                    bne Le2f0
                    dex
                    bne Le2f0
                    tsx                     ; restore X reg to "times to flash"
                    jmp Le2a6

;---------------------------------------------------------------------------------------------------------------------------
; Zero Page Test
; This clobbers firstUnusedZP..$00ff
;---------------------------------------------------------------------------------------------------------------------------

Test_ZeroPage       lda #31                 ; arrow left
                    sta ScreenMemStart+ZPMsgOff+13
                    ldx #$13
Le307               lda TestPatterns,x
                    ldy #firstUnusedZP
-                   sta $0000,y
                    iny
                    bne -
                    txa
                    ldx #$00
                    ldy #$00
-                   dey                     ; delay
                    bne -
                    dex
                    bne -
                    tax
                    ldy #firstUnusedZP
-                   lda TestPatterns,x
                    eor $0000,y
                    bne ZP_Error
                    iny
                    bne -
                    dex
                    bpl Le307

                    ldy #$02                ; invert first page twice then check
-                   lda $0000,y
                    tax
                    eor #$ff
                    sta $0000,y
                    lda $0000,y
                    eor #$ff
                    sta $0000,y
                    txa
                    eor $0000,y
                    bne ZP_Error
                    iny
                    bne -

                    +WriteStr_A ScreenMemStart, ZPMsgOff+13, ColorTextOk, "ok"
                    rts

ZP_Error            tax
                    +WriteStr_A ScreenMemStart, ZPMsgOff+13, ColorTextBad, "bad"
                    jmp RamTest_Error_Bit_0
                    
;---------------------------------------------------------------------------------------------------------------------------
; Color Ram Test
;---------------------------------------------------------------------------------------------------------------------------

Test_ColorRam       lda #31                 ; arrow left
                    sta ScreenMemStart+ColMsgOff+13
                    ldx #$00
                    ldy #$d8
                    stx tmp1Ptr
                    sty tmp1PtrHi
                    ldy #$00
Le41b               ldy #$00
                    lda (tmp1Ptr),y
                    pha
                    ldx #$0b
Le422               lda ColorRamTP,x
                    sta (tmp1Ptr),y
                    txa
                    ldx #$00
Le42a               dex
                    bne Le42a
                    tax
                    lda (tmp1Ptr),y
                    and #$0f
                    cmp ColorRamTP,x
                    bne Test_ColorRam_Err
                    dex
                    bpl Le422
                    pla
                    sta (tmp1Ptr),y
                    inc tmp1Ptr
                    bne Le443
                    inc tmp1PtrHi
Le443               lda tmp1PtrHi
                    cmp #$dc
                    bne Le41b
                    +WriteStr_A ScreenMemStart, ColMsgOff+13, ColorTextOk, "ok"
                    rts
                    
Test_ColorRam_Err   eor ColorRamTP,x
                    tax
                    +WriteStr_A ScreenMemStart, ColMsgOff+13, ColorTextBad, "bad"
                    jmp RamTest_Error_Bit_0


;---------------------------------------------------------------------------------------------------------------------------
; CIA1 Timer Interrupt Test
;---------------------------------------------------------------------------------------------------------------------------

Test_Cia1Test       lda #$00
                    sta $dc0e                  ; stop Timer A
                    lda #$7f
                    sta $dc0d                  ; don't actually trigger any IRQ
                    lda $dc0d                  ; clear Int Data
                    lda #$05
                    sta $dc04                  ; CIA1 Timer A Low
                    lda #$00
                    sta $dc05                  ; CIA1 Timer A High
                    lda $dc0d
                    and #$01
                    bne CIA1Fail
                    lda #$01
                    sta $dc0e                  ; start Timer A
                    lda $dc0d
                    and #$01
                    bne CIA1Fail               ; shouldn't have triggered yet
                    lda $dc0d
                    and #$01
                    beq CIA1Fail               ; but NOW it should have triggered
                    +WriteStr_A ScreenMemStart, Cia1MsgOff+13, ColorTextOk, "ok"
                    rts
CIA1Fail:           +WriteStr_A ScreenMemStart, Cia1MsgOff+13, ColorTextBad, "bad"
                    rts

;---------------------------------------------------------------------------------------------------------------------------
; Copy relocatable tests to RAM
;---------------------------------------------------------------------------------------------------------------------------

Test_RunTestsFromRam
                    lda #<RelocatableCodeStart ; copy tests to RAM
                    sta tmp1Ptr
                    lda #>RelocatableCodeStart
                    sta tmp1PtrHi
                    lda #<TestsInRamStart
                    sta tmp2Ptr
                    lda #>TestsInRamStart
                    sta tmp2PtrHi
                    ldy #$00
-                   lda (tmp1Ptr),y
                    sta (tmp2Ptr),y
                    iny
                    bne -
                    inc tmp1PtrHi
                    inc tmp2PtrHi
                    lda #>TestsInRamEnd
                    cmp tmp2PtrHi
                    bne -

                    ; patch RamTest in RAM to test $1000 to $ffff and return using RTS
                    lda #$10
                    sta Test_RamTestStartPage1 - RelocatableCodeStart + TestsInRamStart
                    sta Test_RamTestStartPage2 - RelocatableCodeStart + TestsInRamStart
                    lda #$00
                    sta Test_RamTestEndPage1 - RelocatableCodeStart + TestsInRamStart
                    sta Test_RamTestEndPage2 - RelocatableCodeStart + TestsInRamStart
                    sta Test_RamTestStartLo1 - RelocatableCodeStart + TestsInRamStart
                    sta Test_RamTestStartLo2 - RelocatableCodeStart + TestsInRamStart
                    ; this variant of the RAM test tests from $1000 and does not
                    ; clobber screen/stack so disable that part of the code
                    lda #$60  ; RTS
                    sta Test_RamTestReturn - RelocatableCodeStart + TestsInRamStart
                    lda #$2C  ; BIT $xxxx
                    sta Test_RamTestScrn1 - RelocatableCodeStart + TestsInRamStart
                    sta Test_RamTestScrn2 - RelocatableCodeStart + TestsInRamStart
                    lda #120   ; move down 64k test result output by three lines
                    sta Test_RamTest_scroff - RelocatableCodeStart + TestsInRamStart

                    lda #$12                   ; use RAM charset
                    sta $d018

                    ; set NMI vectors so that pressing RESTORE doesn't crash the machine
                    lda #<(NMI_Handler_RAM)
                    sta $fffa
                    sta $0318
                    lda #>(NMI_Handler_RAM)
                    sta $fffb
                    sta $0319

                    jsr TrampolineForRelocatableTests
                    rts


;---------------------------------------------------------------------------------------------------------------------------
; START RELOCATABLE ROUTINES
; These get copied to $0a00
;---------------------------------------------------------------------------------------------------------------------------

                    * = RelocatableCodeStart

;---------------------------------------------------------------------------------------------------------------------------
; Sound Test
;---------------------------------------------------------------------------------------------------------------------------

!pseudopc TestsInRamStart { ; This only ever gets executed after being copied to RAM so we can use pseudopc here

SidRegOff = prngA

SidDataWaves        !hex 11 25 45 81 00  ; note this must not cross a page boundary
SidDataFreqs        !hex 14 00 25 11 9a 15 b1 19 4b 22 b1 19 9a 15 ff ; volume, regoff, (freqlo,freqhi)*x, endflag
                    !hex 18 07 4b 22 34 2b 61 33 95 44 61 33 34 2b ff
                    !hex 1f 0e 95 44 69 56 c2 66 2b 89 c2 66 69 56 00

Test_SoundTest      lda #31                 ; arrow left
                    sta ScreenMemStart+SoundMsgOff+13

                    ldy #$18
                    lda #$00
-                   sta $d400,y            ; init SID registers to 0
                    dey
                    bpl -

                    lda #$08               ; pulse width for all voices
                    sta $d403
                    sta $d40a
                    sta $d411
                    lda #$3a               ; attack for all voices
                    sta $d405
                    sta $d40c
                    sta $d413
                    lda #$ca               ; sustain for all voices
                    sta $d406
                    sta $d40d
                    sta $d414

                    lda #>(SidDataWaves)
                    sta tmp1PtrHi
                    lda #<(SidDataWaves)
                    sta tmp1Ptr

Test_SoundNextWave  ldy #$00               ; Y=data offset, X=SID register offset
                    lda #>(SidDataFreqs)
                    sta tmp2PtrHi
                    lda #<(SidDataFreqs)
                    sta tmp2Ptr

Test_SoundNextVce   lda (tmp2Ptr),y
                    sta $d418              ; init volume
                    iny
                    lda (tmp2Ptr),y        ; get register offset
                    sta SidRegOff
                    iny
Test_SoundNextNote  ldx SidRegOff
                    lda (tmp2Ptr),y        ; init freqlo
                    bne +
                    inc tmp1Ptr            ; played all notes, next waveform
                    ldy #$00
                    lda (tmp1Ptr),y
                    bne Test_SoundNextWave
                    lda #$00               ; shut down SID
                    sta $d418
                    lda #32                ; space
                    sta ScreenMemStart+SoundMsgOff+13
                    rts

+                   cmp #$ff
                    bne +
                    iny                    ; next voice (and volume)
                    bne Test_SoundNextVce  ; unconditional jump

+                   sta $d400,x
                    inx
                    iny
                    lda (tmp2Ptr),y        ; init freqhi
                    sta $d400,x
                    tya
                    pha
                    ldy #$00
                    lda (tmp1Ptr),y        ; get waveform
                    inx
                    inx
                    inx
                    sta $d400,x            ; start sound
                    lda #$6a

SoundDelayLoop      ; clobbers Y
                    tay
                    txa
                    pha
                    tya
                    tax
--                  ldy #$ff
-                   dey
                    bne -
                    dex
                    bne --
                    pla
                    tax

                    pla
                    tay
                    lda #$00               ; stop sound
                    sta $d400,x
                    iny
                    bne Test_SoundNextNote ; unconditional jump

;---------------------------------------------------------------------------------------------------------------------------
; Relocatable code trampoline
;---------------------------------------------------------------------------------------------------------------------------

RamTest64kMsgLen = 63
strRamTest64k       !scr "ram test 64k is running, screen will be restored in 45 seconds."
strCrcBasic         !scr "basic crc"
strCrcKernal        !scr "kernal crc"
strCrcCharset       !scr "charrom crc"

TrampolineForRelocatableTests
                    +Flip_Cass_Port_A
                    jsr Test_SoundTest

                    +Flip_Cass_Port_A
                    +UltimaxMode_A
                    bcc +
                    jsr TrampolineNextPass
                    rts                     ; in Ultimax mode, cannot run further test

                    ; we can run RamTest in 64k mode!
+                   lda #($0800/$0800*2)    ; use charset from RAM (and screen at $0)
                    sta $d018
                    +CopyStr_AX strRamTest64k, RamTestMsgScrStart, RamTest64kMsgLen
                    +CopyStr_AX strRamTest64k, ScreenMemStart + Ram64MsgOff, 12
                    jsr Test_RamTest_64k - RelocatableCodeStart + TestsInRamStart
                    ; RAM is okay, RAMTest switched VIC back to $0400/$0800 already
                    +WriteStr_A ScreenMemStart, Ram64MsgOff+13, ColorTextOk, "ok"

                    ; We don't need the upper RAM for a few seconds.
                    ; copy charsets and test pattern there for helping with
                    ; debugging possible VIC-II bank selection problems.
                    ldy #$00
                    clc
-                   lda #'1'
                    sta $4400,y
                    lda #'2'
                    sta $8400,y
                    lda #'3'
                    sta $c400,y
                    lda $0800,y
                    sta $4800,y
                    sta $8800,y
                    sta $c800,y
                    iny
                    bne -

                    jsr Test_CRCTest

                    +Flip_Cass_Port_A
                    jsr Test_KeyboardTest

                    jsr TrampolineNextPass

                    lda #>($07c6)           ; just reuse the CRC16 output for COUNT
                    sta tmp1PtrHi
                    lda #<($07c6)
                    sta tmp1Ptr
                    lda passCounterLo
                    sta crc
                    lda passCounterHi
                    sta crc+1
                    ldy #$00
                    jsr CRC_Out

                    sta $ffff
                    sta $fffe
                    lda $ffff
                    cmp #>(IRQ_Handler)
                    bne +
                    lda $fffe
                    cmp #<(IRQ_Handler)
                    bne +
                    rts                     ; our ROM is visible, return
+                   ldy #30                 ; dead test ROM not available:
                    lda #32                 ; delete TOD output as we don't update it
-                   sta ScreenMemStart + 1000 - 30, y
                    dey
                    bpl -
                    jmp TrampolineForRelocatableTests

TrampolineNextPass
                    sed                     ; increment COUNT
                    lda #$01
                    clc
                    adc passCounterLo
                    sta passCounterLo
                    lda #$00
                    adc passCounterHi
                    sta passCounterHi
                    cld
                    rts


NMI_Handler_RAM     inc $d021
                    rti

;---------------------------------------------------------------------------------------------------------------------------
; CRC Test
;---------------------------------------------------------------------------------------------------------------------------

CRCAreas            !8 $a0, $c0, 40+13, $e0, $00, 80+13, $d0, $e0, 120+13, 0  ; startpage,endpage,screenOffset

Test_CRCTest        +CopyStr_AX strCrcBasic, ScreenMemStart + Ram64MsgOff + 40, 9
                    +CopyStr_AX strCrcKernal, ScreenMemStart + Ram64MsgOff + 80, 10
                    +CopyStr_AX strCrcCharset, ScreenMemStart + Ram64MsgOff + 120, 11
                    jsr CRC_MakeTable

                    lda #<(ScreenMemStart + Ram64MsgOff)
                    sta tmp1Ptr
                    lda #>(ScreenMemStart + Ram64MsgOff)
                    sta tmp1PtrHi

                    lda #$33
                    sta $01
                    ldx #$00
-                   lda CRCAreas,x
                    bne +
                    lda #$37
                    sta $01
                    rts
+                   sta CRCStartPage
                    inx
                    lda CRCAreas,x
                    inx
                    stx crc_tmp
                    sta CRCEndPage
                    jsr Calc_CRC_AXY
                    ldx crc_tmp
                    ldy CRCAreas,x
                    jsr CRC_Out
                    ldx crc_tmp
                    inx
                    bne -

Calc_CRC_AXY        ; calculates CRC from CRCStartPage to EndPage, clobbers A, X, Y
                    jsr CRC_Init
                    ldy #$00
CRCStartPage = * + 2
-                   lda $0000,y
                    +CRCUpdate_X
                    iny
                    bne -
                    inc CRCStartPage
                    lda CRCStartPage
CRCEndPage = * + 1
                    cmp #$00
                    bne -
                    rts

HexTab              !scr "0123456789abcdef"

CRC_Out             lda crc+1
                    ror
                    ror
                    ror
                    ror
                    and #$0f
                    tax
                    lda HexTab,x
                    sta (tmp1Ptr),y
                    lda crc+1
                    and #$0f
                    tax
                    lda HexTab,x
                    iny
                    sta (tmp1Ptr),y
                    lda crc
                    ror
                    ror
                    ror
                    ror
                    and #$0f
                    tax
                    lda HexTab,x
                    iny
                    sta (tmp1Ptr),y
                    lda crc
                    and #$0f
                    tax
                    lda HexTab,x
                    iny
                    sta (tmp1Ptr),y
                    rts

; CRC16 routines
; By Paul Guertin (pg@sff.net), 18 August 2000

CRC_MakeTable:
         ldx #0          ; X counts from 0 to 255
--       lda #0          ; A contains the low 8 bits of the CRC-16
         stx crc         ; and CRC contains the high 8 bits
         ldy #8          ; Y counts bits in a byte
-        asl
         rol crc         ; Shift CRC left
         bcc +           ; Do nothing if no overflow
         eor #$21        ; else add CRC-16 polynomial $1021
         pha             ; Save low byte
         lda crc         ; Do high byte
         eor #$10
         sta crc
         pla             ; Restore low byte
+        dey
         bne -           ; Do next bit
         sta crclo,x     ; Save CRC into table, low byte
         lda crc         ; then high byte
         sta crchi,x
         inx
         bne --          ; Do next byte
         rts

CRC_Init:                ; Paul uses #$ff but we stay with the CRC-CITT/CRC16-XMODEM standard
         lda #$00
         sta crc
         sta crc+1
         rts

;---------------------------------------------------------------------------------------------------------------------------
; Keyboard Test
;---------------------------------------------------------------------------------------------------------------------------

strKeyboardTest     !scr "keyboard"
Test_KeyCounter     !hex 00
KeyboardMsgOff = Ram64MsgOff + 160

Test_KeyboardTest   lda #31                 ; arrow left
                    sta ScreenMemStart+KeyboardMsgOff+13+18
                    +CopyStr_AX strKeyboardTest, ScreenMemStart + KeyboardMsgOff, 8

--                  ldx #$ff
                    stx $dc03               ; port B output
                    inx
                    stx $dc01               ; port B all low
                    stx $dc00
                    stx $dc02
                    lda $dc00
                    ldy #13
                    jsr Test_KeyboardPrint
                    ldx #$00
                    stx $dc03               ; port B input
                    dex
                    stx $dc02               ; port A output, all low
                    ldy #$40
-                   dex
                    bne -
                    dey
                    bne -
                    inc Test_KeyCounter
                    beq Test_KeyboardEnd
                    lda $dc01
                    ldy #22
                    jsr Test_KeyboardPrint
                    jmp --

Test_KeyboardEnd    lda #32                 ; delete keyboard output again
                    ldy #18
-                   sta ScreenMemStart+KeyboardMsgOff+13,y
                    dey
                    bpl -
                    rts

Test_KeyboardPrint  ldx #$08
-                   clc
                    rol
                    pha
                    bcc +
                    lda #42                 ; "*"
                    bcs ++
+                   lda #48                 ; "0"
++                  sta ScreenMemStart + KeyboardMsgOff,y
                    pla
                    iny
                    dex
                    bne -
                    rts

} ; end of pseudopc part

;---------------------------------------------------------------------------------------------------------------------------
; RAM Test
; For the first 4 kBytes check, this runs from ROM
; Gets copied to RAM (and patched) for 64k test in KERNAL/non-Ultimax mode
; Stays in ROM for simple 4k check
;---------------------------------------------------------------------------------------------------------------------------

RamTestBegin        = RamTestMsgScrStart + RamTestLongMsgLen + 1

Test_RamTest_64k    ; called when running from RAM
                    lda $01                 ; disable ROMs/IO
                    and #$f8
                    sta $01

Test_RamTest        ; called when running from ROM
                    ldx #$00
Test_RamTestStartPage1 = * + 1              ; for 64k test patching
                    ldy #>RamTestBegin
                    stx tmp1Ptr
                    sty tmp1PtrHi
                    ldx passCounterLo
                    inx                     ; avoid seeding PRNG with 0
                    txa
                    +PRNG_Init
Test_RamTestStartLo1 = * + 1                ; for 64k test patching
                    ldy #<RamTestBegin
Test_RamTest_2      ldx #$13
Test_RamTest_3      lda TestPatterns,x
                    sta (tmp1Ptr),y
                    lda (tmp1Ptr),y
                    eor TestPatterns,x
                    beq +
                    bne Test_RamTest_dbne   ; error
+                   dex
                    bpl Test_RamTest_3
                    +PRNG_Generate
                    sta (tmp1Ptr),y         ; store PRNG byte
                    iny                     ; next address
                    bne Test_RamTest_2
                    inc tmp1PtrHi
                    lda tmp1PtrHi
Test_RamTestEndPage1 = * + 1                ; for 64k test patching
                    cmp #>($1000)           ; in 4k test, ends at $1000
                    bne Test_RamTest_2

Test_RamTest_dbne   bne Test_RamTest_Error  ; double bne for "long" bne

                    ; verify PRNG bytes
                    ldx passCounterLo
                    inx
                    txa
                    +PRNG_Init
Test_RamTestStartPage2 = * + 1              ; for 64k test patching
                    ldy #>RamTestBegin
                    sty tmp1PtrHi
                    ldy #$00
                    sty tmp1Ptr
Test_RamTestStartLo2 = * + 1                ; for 64k test patching
                    ldy #<RamTestBegin
-                   +PRNG_Generate
                    cmp (tmp1Ptr),y
                    beq +
                    lda #$00
                    beq Test_RamTest_Error
+                   iny
                    bne -
                    inc tmp1PtrHi
                    lda tmp1PtrHi
Test_RamTestEndPage2 = * + 1                ; for 64k test patching
                    cmp #>($1000)           ; in 4k test, ends at $1000
                    bne -
                    beq Test_RamTest_Ok

Test_RamTest_Error  tay
                    lda $01
                    ora #$07
                    sta $01
                    tya
                    clc
                    bcc Test_RamTest_BitErr

Test_RamTest_Ok     ; all ok, reset memory layout and jump back
                    lda $01
                    ora #$07
                    sta $01
Test_RamTestScrn1 = *                       ; for RAM only test patching (BIT instead of JSR)
                    jsr SetupTextScreen
                    lda #$12
                    sta $d018               ; switch VIC-II to RAM again
                    lda #$0f                ; "O"
                    sta ScreenMemStart+RamMsgOff+13
                    sta ScreenMemStart+ZPMsgOff+13   ; oh well, just restore the ZP/Col "OK"s, too
                    sta ScreenMemStart+ColMsgOff+13
                    lda #$0b                ; "K"
                    sta ScreenMemStart+RamMsgOff+14
                    sta ScreenMemStart+ZPMsgOff+14
                    sta ScreenMemStart+ColMsgOff+14
                    lda #ColorTextOk
                    sta ColMemStart+RamMsgOff+13
                    sta ColMemStart+ZPMsgOff+13
                    sta ColMemStart+ColMsgOff+13
                    sta ColMemStart+RamMsgOff+14
                    sta ColMemStart+ZPMsgOff+14
                    sta ColMemStart+ColMsgOff+14
Test_RamTestReturn = *                      ; for 64k test patching (RTS instead of JMP)
                    jmp BackFromRAMTest

Test_RamTest_BitErr ; expects bit errors in A or zero on PRNG check error
                    tax
                    txs                     ; just use S as temp register, stack is unreliable anyways
                    lda #$12
                    sta $d018               ; switch VIC-II to RAM again
                    ldy #$ff
Test_RamTestScrn2 = *                       ; for RAM only test patching (BIT instead of JMP)
                    jmp SetupTextScreen     ; this will not use RTS because of Y>0
Test_RamTest_Return
Test_RamTest_scroff = * + 1                 ; for RAM only test patching (80 chars display offset)
                    ldy #$00
                    tsx
                    bne +
                    +WriteStrYOff_A ScreenMemStart, RamMsgOff+13, ColorTextBad, "adrfail"
                    clc
                    bcc RamTest_Error_Bit_0
+                   +WriteStrYOff_A ScreenMemStart, RamMsgOff+13, ColorTextBad, "bad"
RamTest_Error_Bit_0 txa
                    and #$01
                    beq RamTest_Error_Bit_1
                    +WriteStr_A ScreenMemStart, $02a4, ColorTextBad, "bad"
RamTest_Error_Bit_1 txa
                    and #$02
                    beq RamTest_Error_Bit_2
                    +WriteStr_A ScreenMemStart, $02a0, ColorTextBad, "bad"
RamTest_Error_Bit_2 txa
                    and #$04
                    beq RamTest_Error_Bit_3
                    +WriteStr_A ScreenMemStart, $029c, ColorTextBad, "bad"
RamTest_Error_Bit_3 txa
                    and #$08
                    beq RamTest_Error_Bit_4
                    +WriteStr_A ScreenMemStart, $0298, ColorTextBad, "bad"
RamTest_Error_Bit_4 txa
                    and #$10
                    beq RamTest_Error_Bit_5
                    +WriteStr_A ScreenMemStart, $0294, ColorTextBad, "bad"
RamTest_Error_Bit_5 txa
                    and #$20
                    beq RamTest_Error_Bit_6
                    +WriteStr_A ScreenMemStart, $0290, ColorTextBad, "bad"
RamTest_Error_Bit_6 txa
                    and #$40
                    beq RamTest_Error_Bit_7
                    +WriteStr_A ScreenMemStart, $028c, ColorTextBad, "bad"
RamTest_Error_Bit_7 txa
                    and #$80
                    beq LoopUntilDoomsday
                    +WriteStr_A ScreenMemStart, $0288, ColorTextBad, "bad"

LoopUntilDoomsday   inc $d020
                    clc
                    bcc LoopUntilDoomsday   ; NO CARRIER

;---------------------------------------------------------------------------------------------------------------------------
; END RELOCATABLE ROUTINES
;---------------------------------------------------------------------------------------------------------------------------

                    * = $f000

;---------------------------------------------------------------------------------------------------------------------------
; Update TOD1 display
;---------------------------------------------------------------------------------------------------------------------------

UpdateTod1Display   lda $dc0b               ; test for PM flag
                    clc
                    asl
                    bcc OutText_TOD1_AM
                    
                    lda #$10                ; "P"
                    sta $07db
                    lda #$0d                ; "M"
                    sta $07dc
                    clc
                    bcc Skip_TOD1_AM
                    
OutText_TOD1_AM     lda #$01                ; "A"
                    sta $07db
                    lda #$0d                ; "M"
                    sta $07dc

Skip_TOD1_AM        lda $dc0b               ; read hours
                    and #$7f                ; only lower 7 bits, PM flag already tested before
                    ldy #$01                ; two digits
                    bne Le732
                    
Le700               sta $07d3
                    stx $07d4
                    lda #$2d                ; "-"
                    sta $07d5
                    lda $dc0a
                    ldy #$02
                    bne Le732
Le712               sta $07d6
                    stx $07d7
                    lda #$2d                ; "-"
                    sta $07d8
                    lda $dc09
                    ldy #$03
                    bne Le732
Le724               sta $07d9
                    stx $07da
                    lda $dc08
                    clc
                    bcc UpdateTod2Display
                    ldy #$00

Le732               pha                     ; save value
                    sty $10                 
                    ldy #$04
                    bne Le741
Le739               ldy $10
                    tax
                    pla
                    lsr
                    lsr
                    lsr
                    lsr
Le741               and #$0f                ; ones digit
                    cmp #$0a
                    bmi Le74c
                    sec
                    sbc #$09
                    bne Le74e
Le74c               ora #$30
Le74e               cpy #$01
                    beq Le700
                    cpy #$02
                    beq Le712
                    cpy #$03
                    beq Le724
                    cpy #$04
                    beq Le739
                    cpy #$05
                    beq Le792
                    cpy #$06
                    beq Le7a4
                    cpy #$07
                    beq Le7b6
                    rts
                    
;---------------------------------------------------------------------------------------------------------------------------
; Update TOD2 display
;---------------------------------------------------------------------------------------------------------------------------

UpdateTod2Display   lda $dd0b
                    clc
                    asl
                    bcc Le77f
                    lda #$10
                    sta $07e6
                    lda #$0d
                    sta $07e7
                    clc
                    bcc Le789
Le77f               lda #$01
                    sta $07e6
                    lda #$0d
                    sta $07e7
Le789               lda $dd0b
                    and #$7f
                    ldy #$05
Le790               bne Le732
Le792               sta $07de
                    stx $07df
                    lda #$2d
                    sta $07e0
                    lda $dd0a
                    ldy #$06
                    bne Le790
Le7a4               sta $07e1
                    stx $07e2
                    lda #$2d
                    sta $07e3
                    lda $dd09
                    ldy #$07
                    bne Le790
Le7b6               sta $07e4
                    stx $07e5
                    lda $dd08
                    rts

;---------------------------------------------------------------------------------------------------------------------------
; Strings
;---------------------------------------------------------------------------------------------------------------------------

                    !align 255,0  ; not strictly necessary

strCaption          !scr "github.com/c1570/c64-dead-test  20250804" ; 40 chars fixed text (one line)
strCount            !scr "count"                                    ;  5 chars fixed text
strZeroPage         !scr "zero page"                                ;  9 chars fixed text
strColorRam         !scr "color ram"                                ;  9 chars fixed text
strRamTest          !scr "ram test 4kb is running, screen will be restored in a few seconds."
strCia1Test         !scr "cia1 timer a"                             ; 12 chars fixed text
strSoundTest        !scr "sound test"                               ; 10 chars fixed text

;---------------------------------------------------------------------------------------------------------------------------
; Constants and Tables
;---------------------------------------------------------------------------------------------------------------------------

TestPatterns        !hex 00 55 aa ff 01 02 04 08 10 20 40 80 fe fd fb f7
                    !hex ef df bf 7f

ColorRamTP          !hex 00 05 0a 0f 01 02 04 08 0e 0d 0b 07

VicInit             !hex 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                    !hex 00 1b 00 00 00 00 08 00 12 00 00 00 00 00 00 00
                    !hex 03 01 00 00 00 00 00 00 00 00 00 00 00 00 00

Cia1Init            !hex 00 00 00 00 00

Cia2Init            !hex 00 00 00 00 80

StatusHeader        !scr 34, "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&", 35

                    ;     123456789.123456789.123456789.123456789."
StatusText          !scr 39, "bit    d7  d6  d5  d4  d3  d2  d1  d0 ", 39
                    !scr 39, "status ok  ok  ok  ok  ok  ok  ok  ok ", 39
                    !scr 39, "                                      ", 39
                    !scr 39, " 4164  u12 u24 u11 u23 u10 u22 u9  u21", 39
                    !scr 39, "250466 u9  u9  u9  u9  u10 u10 u10 u10", 39
                    !scr 39, "250469 u11 u11 u11 u11 u10 u10 u10 u10", 39
                    !hex ff

StatusColor         !hex 02 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 02
                    !hex 02 06 06 06 06 06 06 06 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 02
                    !hex 02 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 02
                    !hex 02 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 02
                    !hex 02 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 02
                    !hex 02 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 02
                    !hex ff

StatusFooter        !scr 36, "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&", 37

;---------------------------------------------------------------------------------------------------------------------------
; Integrated character set, 63 chars standard PETSCII
; Chars 34..39 replaced with PETSCII for drawing the frame.
;---------------------------------------------------------------------------------------------------------------------------

                    * = $f800       ; fixed position as we switch to ROM charset occasionally

:CharSet            !hex 3c 66 6e 6e 60 62 3c 00        ; @
                    !hex 18 3c 66 7e 66 66 66 00        ; A
                    !hex 7c 66 66 7c 66 66 7c 00        ; B
                    !hex 3c 66 60 60 60 66 3c 00        ; C
                    !hex 78 6c 66 66 66 6c 78 00        ; D
                    !hex 7e 60 60 78 60 60 7e 00        ; E
                    !hex 7e 60 60 78 60 60 60 00        ; F
                    !hex 3c 66 60 6e 66 66 3c 00        ; G
                    !hex 66 66 66 7e 66 66 66 00        ; H
                    !hex 3c 18 18 18 18 18 3c 00        ; I
                    !hex 1e 0c 0c 0c 0c 6c 38 00        ; J
                    !hex 66 6c 78 70 78 6c 66 00        ; K
                    !hex 60 60 60 60 60 60 7e 00        ; L
                    !hex 63 77 7f 6b 63 63 63 00        ; M
                    !hex 66 76 7e 7e 6e 66 66 00        ; N
                    !hex 3c 66 66 66 66 66 3c 00        ; O
                    !hex 7c 66 66 7c 60 60 60 00        ; P
                    !hex 3c 66 66 66 66 3c 0e 00        ; Q
                    !hex 7c 66 66 7c 78 6c 66 00        ; R
                    !hex 3c 66 60 3c 06 66 3c 00        ; S
                    !hex 7e 18 18 18 18 18 18 00        ; T
                    !hex 66 66 66 66 66 66 3c 00        ; U
                    !hex 66 66 66 66 66 3c 18 00        ; V
                    !hex 63 63 63 6b 7f 77 63 00        ; W
                    !hex 66 66 3c 18 3c 66 66 00        ; X
                    !hex 66 66 66 3c 18 18 18 00        ; Y
                    !hex 7e 06 0c 18 30 60 7e 00        ; Z
                    !hex 3c 30 30 30 30 30 3c 00        ; [
                    !hex 0e 10 30 fe 30 60 ff 00        ; <pound symbol>
                    !hex 3c 0c 0c 0c 0c 0c 3c 00        ; ]
                    !hex 00 18 3c 7e 18 18 18 18        ; <arrow up>
                    !hex 00 10 30 7f 7f 30 10 00        ; <arrow left>
                    !hex 00 00 00 00 00 00 00 00        ; <space>
                    !hex 18 18 18 18 00 00 18 00        ; !
                    !hex 00 00 00 07 0f 1c 18 18        ; <frame upper left corner>
                    !hex 00 00 00 e0 f0 38 18 18        ; <frame upper right corner>
                    !hex 18 18 1c 0f 07 00 00 00        ; <frame lower left corner>
                    !hex 18 18 38 f0 e0 00 00 00        ; <frame lower right corner>
                    !hex 00 00 00 ff ff 00 00 00        ; <frame horizontal line>
                    !hex 18 18 18 18 18 18 18 18        ; <frame vertical line>
                    !hex 0c 18 30 30 30 18 0c 00        ; (
                    !hex 30 18 0c 0c 0c 18 30 00        ; )
                    !hex 00 66 3c ff 3c 66 00 00        ; *
                    !hex 00 18 18 7e 18 18 00 00        ; +
                    !hex 00 00 00 00 00 18 18 30        ; ,
                    !hex 00 00 00 7e 00 00 00 00        ; -
                    !hex 00 00 00 00 00 18 18 00        ; .
                    !hex 00 03 06 0c 18 30 60 00        ; /
                    !hex 3c 66 6e 76 66 66 3c 00        ; 0
                    !hex 18 18 38 18 18 18 7e 00        ; 1
                    !hex 3c 66 06 0c 30 60 7e 00        ; 2
                    !hex 3c 66 06 1c 06 66 3c 00        ; 3
                    !hex 06 0e 1e 66 7f 06 06 00        ; 4
                    !hex 7e 60 7c 06 06 66 3c 00        ; 5
                    !hex 3c 66 60 7c 66 66 3c 00        ; 6
                    !hex 7e 66 0c 18 18 18 18 00        ; 7
                    !hex 3c 66 66 3c 66 66 3c 00        ; 8
                    !hex 3c 66 66 3e 06 66 3c 00        ; 9
                    !hex 00 00 00 18 00 00 18 00        ; :
                    !hex 00 00 18 00 00 18 18 30        ; ;
                    !hex 0e 18 30 60 30 18 0e 00        ; <
                    !hex 00 00 7e 00 7e 00 00 00        ; =
                    !hex 70 18 0c 06 0c 18 70 00        ; >
                    !hex 3c 66 06 0c 18 00 18 00        ; ?

;---------------------------------------------------------------------------------------------------------------------------
; CPU vectors, etc
;---------------------------------------------------------------------------------------------------------------------------

                    * = $fff5
:NMI_Handler        inc $d021
:IRQ_Handler        rti

                    * = $fff9
:ROMChecksum        !hex 00
                    !word NMI_Handler
                    !word Reset_Handler
                    !word IRQ_Handler
